class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        m,n = len(graph), len(graph[0])
        self.size = {x:1 for x in range(m)}
        self.uf = {x:x for x in range(m)}
        self.comp = m
        
        def find(x):
            if x!=self.uf[x]:
                self.uf[x] = find(self.uf[x])
            return self.uf[x]
        
        def union(x,y):
            px,py = find(x), find(y)
            if px==py: return False
            
            if self.size[px]>self.size[py]:
                self.uf[py]=px
                self.size[px] += self.size[py]
            else:
                self.uf[px]=py
                self.size[py]+=self.size[px]
                
        # figuring which nodes are connected in all.
        # using this UF, we can figure, each component has how many nodes. 
        # nothing we have done with initial yet, just creating nodes in groups. 
        for i in range(m):
            for j in range(n):
                if graph[i][j] and i!=j:
                    union(i, j)
        
        # for all the infected nodes, we figure how many components belong to them
        # Something like component to number of infected nodes
        # {
        #     comp1: 2, comp2: 1, comp3: 3
        # }
        # ultimately idea is we will only consider removing infected nodes, whose component just contains 1 infected node. 
        # using the UF above, we will now find in infected nodes, how many belong to the same group
        # and in the same group, 
        comp_to_infected = Counter(find(x) for x in initial)
        
        res, max_size = min(initial), 0
        
        # now find the component having just 1 infected node
        # if we have multiple components having just 1 infected node, remvoe the one whose size is maximum. 
        for i in initial:
            count = comp_to_infected[find(i)]
            if count!=1: continue
            
            # we need to remove the node, such that only 1 infected in the component
            # and group wise, it contains maximum number of elements. 
            size = self.size[find(i)]
            if size>max_size:
                max_size, res = size, i
            elif size==max_size:
                res = min(res, i)
        
        # returning res, either min initial.
        return res
    